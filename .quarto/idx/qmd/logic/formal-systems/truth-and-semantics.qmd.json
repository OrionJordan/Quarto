{"title":"Truth and Semantics","markdown":{"yaml":{"title":"Truth and Semantics","format":{"html":{"toc":true,"html-math-method":"katex"}}},"headingText":"Truth Assignment in Proposition logic","containsRefs":false,"markdown":"\n\nWe now know how to create a formal language, and how to create new formulas in said system. However, as of now these formulas are merely strings of symbols with no meaning or truth attached to them. Logic isn't very useful without truth, so lets establish some way of assigning truth to a formula.\n\n\nIn order to keep things simple, we'll be using [**propositional logic**]{style=\"color: blue\"} as our example for truth assignment. Proposition logic contains no quantifiers, functions, relations, or equality, so it'll be simple to work with. Of course a formal definition of propositional logic will be given later, but for now it serves as a simple example for truth.\n\n::: {.callout-note icon=\"false\"}\n## Definition\n\nA [**truth value**]{style=\"color: blue\"} is some value relating to the truth of a statement. \n:::\n\nMost logic contains only two truth values, *truth* denoted $T$ or $1$, and *falsity* denoted $F$ or $0$. There is however no limit to the amount of truth values one could have. \n\n::: {.callout-note icon=\"false\"}\n## Definition\n\nA [**truth assignment**]{style=\"color: blue\"} is some function $v$ such that for the set of terms $T^S$\n\n$$\nv \\colon T^S \\to \\{T,F\\}\n$$\n:::\n\nThus a truth assignment would take every term, and assign the term as either true or false. It is important to note that $v$ only assigns truth to terms. This is to avoid seemingly contradictory statements like\n\n$$\nv(p \\land q) = T\\quad v(p) = F,\n$$\n\nwhich treats the 'And' operator very differently from common expection. The solution to this to define a function $\\overline{v}$, which operates on the set of wff for a language\n\n$$\n\\overline{v} \\colon \\mathcal{L}^S \\to \\{T,F\\},\n$$\n\nand assigns the correct truth value to each formula. We define this function such that for any term $p$, \n$\\overline{v}(p) = v(p)$. We define our operators using [**truth tables**]{style=\"color: blue\"}, which gives the truth value for each operator depending on the truth value of the terms.\n\n\\begin{array}{|c c c c c c c|}\n% |c c|c| means that there are three columns in the table and\n% a vertical bar ’|’ will be printed on the left and right borders,\n% and between the second and the third columns.\n% The letter ’c’ means the value will be centered within the column,\n% letter ’l’, left-aligned, and ’r’, right-aligned.\np & q & \\lnot p & p \\land q & p \\lor q & p \\rightarrow q & p \\leftrightarrow q\\\\ % Use & to separate the columns\n\\hline % Put a horizontal line between the table header and the rest.\nT & T & F & T & T & T & T\\\\\nT & F & F & F & T & F & F\\\\\nF & T & T & F & T & T & F\\\\\nF & F & T & F & F & T & T\\\\\n\\end{array}\n\nThis is the standard truth table, used in almost all of classical logic. There exists seperate tables for systems with more than two truth values of course, but you'll (likely) never see the $\\land$ operator defined differently from the table above.\n\nOf course this is just how truth is defined in propositional logic. Truth is defined very different in logical systems like intuitionistic logic. \n\n## Semantic consequence\n\nNow that we have an example of a truth assignment, we can work with more general notions of truth.\n\n::: {.callout-note icon=\"false\"}\n## Definition\n\nWe say a truth assignment $v$ [**satisfies**]{style=\"color: blue\"} $\\varphi$ if and only if $\\overline{v}(\\varphi) = T$. \n:::\n\nThis leads to our next definition\n\n::: {.callout-note icon=\"false\"}\n## Definition\n\nLet $\\Gamma$ and $\\varphi$ be sets of wff. We say $\\varphi$ is a [**Semantic consequence**]{style=\"color: blue\"} of $\\Gamma$ if and only if every truth assignment that satisfies $\\Gamma$ also satisfies $\\varphi$. This is denoted\n\n$$\n\\Gamma \\models \\varphi\n$$\n\n:::\n\nThus, this simply means if $\\Gamma$ is true, $\\varphi$ is too. We define a [**tautology**]{style=\"color: blue\"} $\\tau$ if \n\n$$\n\\models \\tau\n$$\n\nMeaning that $\\tau$ is always true regardless of the truth assignment used. An example of a tautology in classic logic is the *Law of the excluded middle*, denoted\n\n$$\nP \\lor \\lnot P\n$$\n\nWhich is clearly true for all truth values $P$ in propositional logic. However there are systems like intuitionistic logic where truth is defined in a way rejecting the *Law of the excluded middle*.","srcMarkdownNoYaml":"\n\nWe now know how to create a formal language, and how to create new formulas in said system. However, as of now these formulas are merely strings of symbols with no meaning or truth attached to them. Logic isn't very useful without truth, so lets establish some way of assigning truth to a formula.\n\n## Truth Assignment in Proposition logic\n\nIn order to keep things simple, we'll be using [**propositional logic**]{style=\"color: blue\"} as our example for truth assignment. Proposition logic contains no quantifiers, functions, relations, or equality, so it'll be simple to work with. Of course a formal definition of propositional logic will be given later, but for now it serves as a simple example for truth.\n\n::: {.callout-note icon=\"false\"}\n## Definition\n\nA [**truth value**]{style=\"color: blue\"} is some value relating to the truth of a statement. \n:::\n\nMost logic contains only two truth values, *truth* denoted $T$ or $1$, and *falsity* denoted $F$ or $0$. There is however no limit to the amount of truth values one could have. \n\n::: {.callout-note icon=\"false\"}\n## Definition\n\nA [**truth assignment**]{style=\"color: blue\"} is some function $v$ such that for the set of terms $T^S$\n\n$$\nv \\colon T^S \\to \\{T,F\\}\n$$\n:::\n\nThus a truth assignment would take every term, and assign the term as either true or false. It is important to note that $v$ only assigns truth to terms. This is to avoid seemingly contradictory statements like\n\n$$\nv(p \\land q) = T\\quad v(p) = F,\n$$\n\nwhich treats the 'And' operator very differently from common expection. The solution to this to define a function $\\overline{v}$, which operates on the set of wff for a language\n\n$$\n\\overline{v} \\colon \\mathcal{L}^S \\to \\{T,F\\},\n$$\n\nand assigns the correct truth value to each formula. We define this function such that for any term $p$, \n$\\overline{v}(p) = v(p)$. We define our operators using [**truth tables**]{style=\"color: blue\"}, which gives the truth value for each operator depending on the truth value of the terms.\n\n\\begin{array}{|c c c c c c c|}\n% |c c|c| means that there are three columns in the table and\n% a vertical bar ’|’ will be printed on the left and right borders,\n% and between the second and the third columns.\n% The letter ’c’ means the value will be centered within the column,\n% letter ’l’, left-aligned, and ’r’, right-aligned.\np & q & \\lnot p & p \\land q & p \\lor q & p \\rightarrow q & p \\leftrightarrow q\\\\ % Use & to separate the columns\n\\hline % Put a horizontal line between the table header and the rest.\nT & T & F & T & T & T & T\\\\\nT & F & F & F & T & F & F\\\\\nF & T & T & F & T & T & F\\\\\nF & F & T & F & F & T & T\\\\\n\\end{array}\n\nThis is the standard truth table, used in almost all of classical logic. There exists seperate tables for systems with more than two truth values of course, but you'll (likely) never see the $\\land$ operator defined differently from the table above.\n\nOf course this is just how truth is defined in propositional logic. Truth is defined very different in logical systems like intuitionistic logic. \n\n## Semantic consequence\n\nNow that we have an example of a truth assignment, we can work with more general notions of truth.\n\n::: {.callout-note icon=\"false\"}\n## Definition\n\nWe say a truth assignment $v$ [**satisfies**]{style=\"color: blue\"} $\\varphi$ if and only if $\\overline{v}(\\varphi) = T$. \n:::\n\nThis leads to our next definition\n\n::: {.callout-note icon=\"false\"}\n## Definition\n\nLet $\\Gamma$ and $\\varphi$ be sets of wff. We say $\\varphi$ is a [**Semantic consequence**]{style=\"color: blue\"} of $\\Gamma$ if and only if every truth assignment that satisfies $\\Gamma$ also satisfies $\\varphi$. This is denoted\n\n$$\n\\Gamma \\models \\varphi\n$$\n\n:::\n\nThus, this simply means if $\\Gamma$ is true, $\\varphi$ is too. We define a [**tautology**]{style=\"color: blue\"} $\\tau$ if \n\n$$\n\\models \\tau\n$$\n\nMeaning that $\\tau$ is always true regardless of the truth assignment used. An example of a tautology in classic logic is the *Law of the excluded middle*, denoted\n\n$$\nP \\lor \\lnot P\n$$\n\nWhich is clearly true for all truth values $P$ in propositional logic. However there are systems like intuitionistic logic where truth is defined in a way rejecting the *Law of the excluded middle*."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"html-math-method":"katex","output-file":"truth-and-semantics.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","title":"Truth and Semantics"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}