<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>OOMN - The Tower of Hanoi</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">OOMN</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../qmd/basics/sets.html" rel="" target="">
 <span class="menu-text">Basics</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../qmd/graph/GraphTheory.html" rel="" target="">
 <span class="menu-text">Graph Theory</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../qmd/integral/intro.html" rel="" target="">
 <span class="menu-text">Integral</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-problem" id="toc-the-problem" class="nav-link active" data-scroll-target="#the-problem">The problem</a></li>
  <li><a href="#lines-in-the-plane" id="toc-lines-in-the-plane" class="nav-link" data-scroll-target="#lines-in-the-plane">Lines in the Plane</a></li>
  <li><a href="#the-josephus-problem" id="toc-the-josephus-problem" class="nav-link" data-scroll-target="#the-josephus-problem">The Josephus Problem</a>
  <ul class="collapse">
  <li><a href="#binary-representation" id="toc-binary-representation" class="nav-link" data-scroll-target="#binary-representation">Binary Representation</a></li>
  <li><a href="#generilized-josephus-problem" id="toc-generilized-josephus-problem" class="nav-link" data-scroll-target="#generilized-josephus-problem">Generilized Josephus Problem</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">The Tower of Hanoi</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="the-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-problem">The problem</h2>
<p>The Tower of Hanoi is a problem proposed by Edouard Lucas in 1883. We are given a tower of eight disks stacked in decreasing size on one of three pegs. The objective is to transfer the disks from one peg to another, only moving one disk at a time, and never moving a larger disk onto a smaller one.</p>
<p>Say that <span class="math inline">T_n</span> is the minimum number of moves to transfer a tower of size <span class="math inline">n</span> to another peg. It is clear <span class="math inline">T_1 = 1</span>, and that <span class="math inline">T_2 = 3</span>. Additionally, one could say <span class="math inline">T_0 = 0</span>.</p>
<p>When given a tower of size <span class="math inline">n</span>, it takes <span class="math inline">T_{n-1}</span> moves to move the <span class="math inline">n-1</span> smaller tower onto another peg, one move to move the largest disk onto the desired peg, and then another <span class="math inline">T_{n-1}</span> moves to move the tower of size <span class="math inline">n</span> onto the largest disk. This gives us a general formula</p>
<p><span id="eq-recurrence"><span class="math display">
T_0 = 0;\\
T_n = 2T_{n-1} + 1
\tag{1}</span></span></p>
<p>A set of inequalities like the one shown in <span class="math inline">\left(1\right)</span> is called a <span style="color: blue"><strong>recurrence</strong></span>. Defined by an intial value (<span class="math inline">T_0 = 0</span>) and then a general value in terms of an earlier one <span class="math inline">T_{n} = 2T_{n-1} + 1</span>.</p>
<p>Though finding a numerical value becomes tedious when <span class="math inline">n</span> is large enough. What would reduce computation time is a ‘closed form’ for <span class="math inline">T_n</span>, one that can be evaluated without knowing <span class="math inline">T_n</span> for all smaller values of <span class="math inline">n</span>.</p>
<p>Calculating the first few values of <span class="math inline">T</span>, we get <span class="math inline">T_1 = 1</span>, <span class="math inline">T_2 = 3</span>, <span class="math inline">T_3 = 7</span>, <span class="math inline">T_4 = 15</span>, ect. It would appear that <span id="eq-guess"><span class="math display">
T_n = 2^n - 1 \quad \text{for } n \geq 0
\tag{2}</span></span></p>
<p>But this is not a proof. We can manually confirm it to be true for many values of <span class="math inline">n</span>, but in order to prove it for all values of <span class="math inline">n</span>, we will have to use induction.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Proof
</div>
</div>
<div class="callout-body-container callout-body">
<p>We want to show</p>
<p><span class="math display">
T_n = 2^n - 1.
</span></p>
<p>We use <span class="math inline">n = 0</span> for our basis, which works as <span class="math inline">2^0 - 1 = 0</span>.</p>
<p>By the induction hypothesis</p>
<p><span class="math display">
T_n = 2T_{n-1} + 1 = 2(2^{n-1} - 1) + 1 = 2^n - 1
</span></p>
</div>
</div>
<p>We can use <span class="math inline">n = 0</span> as our basis, as clearly <span class="math inline">T_0 = 2^0 - 1 = 0</span>. The induction follows for <span class="math inline">n &gt; 0</span> if we use the induction hypothesis to say <span class="math inline">(2)</span> holds for <span class="math inline">n - 1</span></p>
<p><span class="math display">
T_n = 2T_{n-1} + 1 = 2(2^{n-1} - 1) + 1 = 2^n - 1
</span></p>
<p>Thus <span class="math inline">(2)</span> holds for <span class="math inline">n</span>. We have now found and proved our closed formula for <span class="math inline">T_n</span> holds.</p>
<p>In order to solve this problem, we first found a mathematical expression that allowed us to solve the problem for any number of disks, and then found a closed form for our mathematical expression. The book will focus primarily on finding these closed forms of mathematical expression, and without using a lucky guess to find the closed form.</p>
<p>Intrestingly enough, our recurrence from <span class="math inline">(1)</span> can be simplified by adding <span class="math inline">1</span> to both sides of the equation:</p>
<p><span class="math display">
T_0 + 1 = 1\\
T_n + 1 = 2T_{n-1} + 2
</span></p>
<p>Now if we let <span class="math inline">U_n = T_n + 1</span>, we get</p>
<p><span id="eq-simprec"><span class="math display">
U_0 = 1\\
U_n = 2U_{n-1}
\tag{3}</span></span></p>
<p>It is pretty clear that our closed formula is <span class="math inline">U_n = 2^n</span>; thus <span class="math inline">T_n = 2^n - 1</span>.</p>
</section>
<section id="lines-in-the-plane" class="level2">
<h2 class="anchored" data-anchor-id="lines-in-the-plane">Lines in the Plane</h2>
<p>Our next problem is on the plane. What is the maximum number <span class="math inline">L_n</span> of regions defined by <span class="math inline">n</span> lines on a plane. This problem was first solved by Jacob Steiner in 1826. If we take a similar approach to the last section, starting with smaller cases:</p>
<p><span class="math display">
L_0 = 1\\
L_1 = 2\\
L_2 = 4
</span></p>
<p>We might come to the natural conclusion that <span class="math inline">L_n = 2^n</span>. And this would be true if each line cut each region in half; but adding a third line makes it clear that we can only split as most <span class="math inline">3</span> regions, giving us <span class="math inline">L_3 = 7</span>. We realize that a new line on the plane adds <span class="math inline">k</span> extra regions if and only if it intersects <span class="math inline">k</span> old regions, and the line intersects <span class="math inline">k</span> regions if and only if it hits the previous lines in <span class="math inline">k-1</span> places. Two lines can intersect in at most one point. So the new line can intersect the <span class="math inline">n - 1</span> lines at <span class="math inline">n-1 places</span>. Thus the upper bound for this problem is</p>
<p><span class="math display">
L_n \leq L_{n-1} + n \quad \text{for} n &gt; 0.
</span></p>
<p>Furthermore it’s easy to change this into equality by adding the restriction that none of the <span class="math inline">n</span> lines are parrall, and that three lines do not intersect at the same point. This ensures that each new line <span class="math inline">n</span> intersects every other line at some new point splitting the region. Our recurrence relation is then</p>
<p><span id="eq-4"><span class="math display">
L_0 = 1;\\
L_n = L_{n-1} + n,\quad \text{for } n &gt; 0.
\tag{4}</span></span></p>
<p>One can verify there are no silly mistakes by checking our established values of <span class="math inline">L_0,L_1</span> and <span class="math inline">L_2</span>. All checks out, so we buy the recurrence relation. Now we need a general formula.</p>
<p>Through some trial and error, we can unfold <span class="math inline">L_n</span> into</p>
<p><span class="math display">
L_n = L_0 + 1 + 2 + \cdots + n
</span></p>
<p>Letting</p>
<p><span class="math display">
S_n = 1 + 2 + \cdots + n
</span></p>
<p>We get the ‘closed form’</p>
<p><span class="math display">
L_n = 1 + S_n
</span></p>
<p>But this just replaces one recurrence for another. It is said that in 1786, when Guass was nine years old, he had found a closed form of <span class="math inline">S_n</span> using the following trick</p>
<span class="math display">\begin{array}{ll}
&amp;S_n &amp;=  &amp;1  &amp;+ &amp;2 &amp;+ \cdots + &amp;(n - 1) &amp;+ &amp;n\\
+&amp;S_n &amp;=  &amp;n  &amp;+ &amp;(n-1) &amp;+ \cdots + &amp;2 &amp;+ &amp;1\\
\hline
2&amp;S_n &amp;= &amp;(n+1) &amp;+ &amp;(n+1) &amp;+ \cdots + &amp;(n+1) &amp;+ &amp;(n+1)
\end{array}\\</span>
<p>Notice how <span class="math inline">2S_n</span> is now just equal to <span class="math inline">n</span> copies of <span class="math inline">(n + 1)</span>, therefore</p>
<p><span id="eq-5"><span class="math display">
S_n = \frac{n(n+1)}{2}, \quad \text{for } n \geq 0
\tag{5}</span></span></p>
<p>Giving us our closed form</p>
<p><span id="eq-6"><span class="math display">
L_n = \frac{n(n+1)}{2} + 1, \quad \text{for } n \geq 0.
\tag{6}</span></span></p>
<p>One might consider this a proof, despite the handwavy techniques used in its derivation. A proof by induction is simple, so we might as well give ourselves some stricter standards. The induction is proved with</p>
<p><span class="math display">
L_n = \frac{(n-1)n}{2} + 1 + n = \frac{n(n+1)}{2} + 1
</span></p>
<p>Thus we have no doubt <span class="math inline">(6)</span> is correct.</p>
<p>We can now look at a vairation of the line problem. Suppose instead of straight lines each line has a zig in it. What is the maximum number <span class="math inline">Z_n</span> of regions determined by <span class="math inline">n</span>. One can see <span class="math inline">Z_1 = 2</span> and <span class="math inline">Z_2 = 7</span>.</p>
<p>From some thought and small cases, one notices that a line with a zig is simply two lines who don’t extend past their intersection point. We can arrange these zigged lines such that the intersection point is far enough from the other lines that we only lose two regions per line. Thus</p>
<p><span id="eq-7"><span class="math display">
Z_n = L_2n - 2n = 2n(2n - 1)/2 + 1 - 2n\\
Z_n = 2n^2 - n + 1 \quad \text{for } n \geq 0.
\tag{7}</span></span></p>
</section>
<section id="the-josephus-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-josephus-problem">The Josephus Problem</h2>
<p>The Josephus problem is actually an ancient problem dating back to the first century. The problem has <span class="math inline">n</span> people standing in a circle. Each person kills the person directly to their left, until there is only one left. We want to find the position of the surviving player.</p>
<p>We can easily see <span class="math inline">J(1) = 1</span>. When there is an even number <span class="math inline">2n</span> of players, note that all the even numbers die the first round. Our circle would then resemble a circle of size <span class="math inline">n</span>, where each players number has been doubled and then had <span class="math inline">1</span> subtracted from it. That is</p>
<p><span class="math display">
J(2n) = 2J(n) - 1
</span></p>
<p>Now if we do a similar thing with an odd number of survivors, we see</p>
<p><span class="math display">
J(2n + 1) = 2J(n) + 1
</span></p>
<p>This can be used to define a recurrence relation</p>
<p><span id="eq-8"><span class="math display">
J(1) = 1\\
J(2n) = 2J(n) - 1\\
J(2n + 1) = 2J(n) + 1
\tag{8}</span></span></p>
<p>This recurrence is much more effienct than our previous ones. As if we wanted to calculate a large <span class="math inline">n</span>, we would need far fewer than <span class="math inline">n</span> steps to get our solution (Around <span class="math inline">\log_2n</span> steps).</p>
<p>Through some trial and error, we can arrive at the following equation</p>
<p><span id="eq-9"><span class="math display">
J(2^m + l) = 2l + 1
\tag{9}</span></span></p>
<p>Which can be solved by induction.</p>
<section id="binary-representation" class="level3">
<h3 class="anchored" data-anchor-id="binary-representation">Binary Representation</h3>
<p>Because powers of <span class="math inline">2</span> played such an important role in finding our solution, one might want to look at <span class="math inline">n</span> in it’s base <span class="math inline">2</span> reprensentation. Suppose</p>
<p><span class="math display">
n = (b_mb_{m-1}\ldots b_1b_0)_2
</span></p>
<p>Note that <span class="math inline">b_m</span> is always <span class="math inline">1</span>. Letting <span class="math inline">n = 2^m + l</span>, we have</p>
<p><span class="math display">
n = (1b_{m-1}\ldots b_1b_0)_2\\
l = (0b_{m-1}\ldots b_1b_0)_2\\
2l = (b_{m-1}\ldots b_1b_00)_2\\
2l + 1 = (b_{m-1}\ldots b_1b_01)_2\\
J(n) = (b_{m-1}\ldots b_1b_0b_m)_2
</span></p>
<p>Thus</p>
<p><span id="eq-10"><span class="math display">
J((1b_{m-1}\ldots b_1b_0)_2) = (b_{m-1}\ldots b_1b_0b_m)_2
\tag{10}</span></span></p>
<p>This means we can find <span class="math inline">J(n)</span> by doing a one-bit cyclic shift left on <span class="math inline">n</span>. Which is insanely simple given the amount of work it was to find a solution in base 10! For example, if <span class="math inline">n = 1101_2</span> then <span class="math inline">J(n) = 1011_2</span>. Note this breaks when <span class="math inline">J(1011_2) = 111_2</span></p>
<p>If we repeatedly apply <span class="math inline">J</span> to a number <span class="math inline">n</span>, we will eventually produce a number consisting of bits which are exclusivly <span class="math inline">1</span>, whos value is <span class="math inline">2^{v(n)} - 1</span> where <span class="math inline">v(n)</span> is the number of bits of value <span class="math inline">1</span> in the binary representation of <span class="math inline">n</span>. Because <span class="math inline">v(13) = 3</span>,</p>
<p><span class="math display">
J(J(\cdots J(13)\cdots)) = 2^3 - 1 = 7.
</span></p>
<p>How many iterations of <span class="math inline">J</span> does it take to get this fixed value? No idea.</p>
</section>
<section id="generilized-josephus-problem" class="level3">
<h3 class="anchored" data-anchor-id="generilized-josephus-problem">Generilized Josephus Problem</h3>
<p>What would happen if we generilized <span class="math inline">(8)</span> with different constants? How would that change our closed form solutions. Lets investiagte this with a more general recurrence</p>
<span class="math display">\begin{array}{ll}
f(1) &amp;=&amp; \alpha;\\
f(2n) &amp;=&amp; 2f(n) + \beta;\\
f(2n + 1) &amp;=&amp; 2f(n) + \gamma;
\end{array}</span>
<p><span id="eq-11"><span class="math display">
\tag{11}</span></span></p>
<p>Our recurrence <span class="math inline">J(n)</span> had constants <span class="math inline">\alpha = 1, \beta = -1 and \gamma = 1</span>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>